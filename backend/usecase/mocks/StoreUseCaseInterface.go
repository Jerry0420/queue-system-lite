// Code generated by mockery v2.9.4. DO NOT EDIT.

package mocks

import (
	context "context"

	domain "github.com/jerry0420/queue-system/backend/domain"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// StoreUseCaseInterface is an autogenerated mock type for the StoreUseCaseInterface type
type StoreUseCaseInterface struct {
	mock.Mock
}

// ChunkStoresSlice provides a mock function with given fields: items, chunkSize
func (_m *StoreUseCaseInterface) ChunkStoresSlice(items [][][]string, chunkSize int) [][][][]string {
	ret := _m.Called(items, chunkSize)

	var r0 [][][][]string
	if rf, ok := ret.Get(0).(func([][][]string, int) [][][][]string); ok {
		r0 = rf(items, chunkSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][][][]string)
		}
	}

	return r0
}

// EncryptPassword provides a mock function with given fields: password
func (_m *StoreUseCaseInterface) EncryptPassword(password string) (string, error) {
	ret := _m.Called(password)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(password)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateCsvFileNameAndContent provides a mock function with given fields: storeCreatedAt, storeTimezone, storeName, content
func (_m *StoreUseCaseInterface) GenerateCsvFileNameAndContent(storeCreatedAt time.Time, storeTimezone string, storeName string, content [][]string) (string, string, []byte) {
	ret := _m.Called(storeCreatedAt, storeTimezone, storeName, content)

	var r0 string
	if rf, ok := ret.Get(0).(func(time.Time, string, string, [][]string) string); ok {
		r0 = rf(storeCreatedAt, storeTimezone, storeName, content)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(time.Time, string, string, [][]string) string); ok {
		r1 = rf(storeCreatedAt, storeTimezone, storeName, content)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 []byte
	if rf, ok := ret.Get(2).(func(time.Time, string, string, [][]string) []byte); ok {
		r2 = rf(storeCreatedAt, storeTimezone, storeName, content)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]byte)
		}
	}

	return r0, r1, r2
}

// GenerateEmailContentOfCloseStore provides a mock function with given fields: storeName, storeCreatedAt
func (_m *StoreUseCaseInterface) GenerateEmailContentOfCloseStore(storeName string, storeCreatedAt string) (string, string) {
	ret := _m.Called(storeName, storeCreatedAt)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(storeName, storeCreatedAt)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, string) string); ok {
		r1 = rf(storeName, storeCreatedAt)
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GenerateEmailContentOfForgetPassword provides a mock function with given fields: passwordToken, store
func (_m *StoreUseCaseInterface) GenerateEmailContentOfForgetPassword(passwordToken string, store domain.Store) (string, string) {
	ret := _m.Called(passwordToken, store)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, domain.Store) string); ok {
		r0 = rf(passwordToken, store)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, domain.Store) string); ok {
		r1 = rf(passwordToken, store)
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GenerateToken provides a mock function with given fields: ctx, store, tokenType, expireTime
func (_m *StoreUseCaseInterface) GenerateToken(ctx context.Context, store domain.Store, tokenType string, expireTime time.Time) (string, error) {
	ret := _m.Called(ctx, store, tokenType, expireTime)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, domain.Store, string, time.Time) string); ok {
		r0 = rf(ctx, store, tokenType, expireTime)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, domain.Store, string, time.Time) error); ok {
		r1 = rf(ctx, store, tokenType, expireTime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TopicNameOfUpdateCustomer provides a mock function with given fields: storeId
func (_m *StoreUseCaseInterface) TopicNameOfUpdateCustomer(storeId int) string {
	ret := _m.Called(storeId)

	var r0 string
	if rf, ok := ret.Get(0).(func(int) string); ok {
		r0 = rf(storeId)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// UpdateStoreDescription provides a mock function with given fields: ctx, newDescription, store
func (_m *StoreUseCaseInterface) UpdateStoreDescription(ctx context.Context, newDescription string, store *domain.Store) error {
	ret := _m.Called(ctx, newDescription, store)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *domain.Store) error); ok {
		r0 = rf(ctx, newDescription, store)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidatePassword provides a mock function with given fields: passwordInDb, incomingPassword
func (_m *StoreUseCaseInterface) ValidatePassword(passwordInDb string, incomingPassword string) error {
	ret := _m.Called(passwordInDb, incomingPassword)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(passwordInDb, incomingPassword)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyPasswordLength provides a mock function with given fields: password
func (_m *StoreUseCaseInterface) VerifyPasswordLength(password string) error {
	ret := _m.Called(password)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyTimeZoneString provides a mock function with given fields: inputTimezone
func (_m *StoreUseCaseInterface) VerifyTimeZoneString(inputTimezone string) error {
	ret := _m.Called(inputTimezone)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(inputTimezone)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// VerifyToken provides a mock function with given fields: ctx, encryptToken, tokenType, withTokenPreserved
func (_m *StoreUseCaseInterface) VerifyToken(ctx context.Context, encryptToken string, tokenType string, withTokenPreserved bool) (domain.TokenClaims, error) {
	ret := _m.Called(ctx, encryptToken, tokenType, withTokenPreserved)

	var r0 domain.TokenClaims
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) domain.TokenClaims); ok {
		r0 = rf(ctx, encryptToken, tokenType, withTokenPreserved)
	} else {
		r0 = ret.Get(0).(domain.TokenClaims)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, encryptToken, tokenType, withTokenPreserved)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
